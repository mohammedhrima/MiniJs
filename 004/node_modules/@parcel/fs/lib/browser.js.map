{"mappings":"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","sources":["packages/core/fs/src/index.js","packages/core/fs/src/NodeFS.browser.js","packages/core/fs/src/MemoryFS.js","packages/core/fs/package.json","node_modules/nullthrows/nullthrows.js","packages/core/fs/src/find.js","packages/core/fs/src/OverlayFS.js"],"sourcesContent":["// @flow strict-local\nimport type {FileSystem} from './types';\nimport type {FilePath} from '@parcel/types';\nimport type {Readable, Writable} from 'stream';\n\nimport path from 'path';\nimport stream from 'stream';\nimport {promisify} from 'util';\n\nexport type * from './types';\nexport * from './NodeFS';\nexport * from './MemoryFS';\nexport * from './OverlayFS';\n\nconst pipeline: (Readable, Writable) => Promise<void> = promisify(\n  stream.pipeline,\n);\n\n// Recursively copies a directory from the sourceFS to the destinationFS\nexport async function ncp(\n  sourceFS: FileSystem,\n  source: FilePath,\n  destinationFS: FileSystem,\n  destination: FilePath,\n) {\n  await destinationFS.mkdirp(destination);\n  let files = await sourceFS.readdir(source);\n  for (let file of files) {\n    let sourcePath = path.join(source, file);\n    let destPath = path.join(destination, file);\n    let stats = await sourceFS.stat(sourcePath);\n    if (stats.isFile()) {\n      await pipeline(\n        sourceFS.createReadStream(sourcePath),\n        destinationFS.createWriteStream(destPath),\n      );\n    } else if (stats.isDirectory()) {\n      await ncp(sourceFS, sourcePath, destinationFS, destPath);\n    }\n  }\n}\n","// @flow\nimport type {FileSystem} from './types';\n\n// $FlowFixMe[prop-missing] handled by the throwing constructor\nexport class NodeFS implements FileSystem {\n  constructor() {\n    throw new Error(\"NodeFS isn't available in the browser\");\n  }\n}\n","// @flow\n\nimport type {FileSystem, FileOptions, ReaddirOptions, Encoding} from './types';\nimport type {FilePath} from '@parcel/types';\nimport type {\n  Event,\n  Options as WatcherOptions,\n  AsyncSubscription,\n} from '@parcel/watcher';\n\nimport path from 'path';\nimport {Readable, Writable} from 'stream';\nimport {registerSerializableClass} from '@parcel/core';\nimport {SharedBuffer} from '@parcel/utils';\nimport packageJSON from '../package.json';\nimport WorkerFarm, {Handle} from '@parcel/workers';\nimport nullthrows from 'nullthrows';\nimport EventEmitter from 'events';\nimport {findAncestorFile, findNodeModule, findFirstFile} from './find';\n\nconst instances: Map<number, MemoryFS> = new Map();\nlet id = 0;\n\ntype HandleFunction = (...args: Array<any>) => any;\ntype SerializedMemoryFS = {\n  id: number,\n  handle: any,\n  dirs: Map<FilePath, Directory>,\n  files: Map<FilePath, File>,\n  symlinks: Map<FilePath, FilePath>,\n  ...\n};\n\ntype WorkerEvent = {|\n  type: 'writeFile' | 'unlink' | 'mkdir' | 'symlink',\n  path: FilePath,\n  entry?: Entry,\n  target?: FilePath,\n|};\n\ntype ResolveFunction = () => mixed;\n\nexport class MemoryFS implements FileSystem {\n  dirs: Map<FilePath, Directory>;\n  files: Map<FilePath, File>;\n  symlinks: Map<FilePath, FilePath>;\n  watchers: Map<FilePath, Set<Watcher>>;\n  events: Array<Event>;\n  id: number;\n  handle: Handle;\n  farm: WorkerFarm;\n  _cwd: FilePath;\n  _eventQueue: Array<Event>;\n  _watcherTimer: TimeoutID;\n  _numWorkerInstances: number = 0;\n  _workerHandles: Array<Handle>;\n  _workerRegisterResolves: Array<ResolveFunction> = [];\n  _emitter: EventEmitter = new EventEmitter();\n\n  constructor(workerFarm: WorkerFarm) {\n    this.farm = workerFarm;\n    this.dirs = new Map([['/', new Directory()]]);\n    this.files = new Map();\n    this.symlinks = new Map();\n    this.watchers = new Map();\n    this.events = [];\n    this.id = id++;\n    this._cwd = '/';\n    this._workerHandles = [];\n    this._eventQueue = [];\n    instances.set(this.id, this);\n    this._emitter.on('allWorkersRegistered', () => {\n      for (let resolve of this._workerRegisterResolves) {\n        resolve();\n      }\n      this._workerRegisterResolves = [];\n    });\n  }\n\n  static deserialize(opts: SerializedMemoryFS): MemoryFS | WorkerFS {\n    let existing = instances.get(opts.id);\n    if (existing != null) {\n      // Correct the count of worker instances since serialization assumes a new instance is created\n      WorkerFarm.getWorkerApi().runHandle(opts.handle, [\n        'decrementWorkerInstance',\n        [],\n      ]);\n      return existing;\n    }\n\n    let fs = new WorkerFS(opts.id, nullthrows(opts.handle));\n    fs.dirs = opts.dirs;\n    fs.files = opts.files;\n    fs.symlinks = opts.symlinks;\n    return fs;\n  }\n\n  serialize(): SerializedMemoryFS {\n    if (!this.handle) {\n      this.handle = this.farm.createReverseHandle(\n        (fn: string, args: Array<mixed>) => {\n          // $FlowFixMe\n          return this[fn](...args);\n        },\n      );\n    }\n\n    // If a worker instance already exists, it will decrement this number\n    this._numWorkerInstances++;\n\n    return {\n      $$raw: false,\n      id: this.id,\n      handle: this.handle,\n      dirs: this.dirs,\n      files: this.files,\n      symlinks: this.symlinks,\n    };\n  }\n\n  decrementWorkerInstance() {\n    this._numWorkerInstances--;\n    if (this._numWorkerInstances === this._workerHandles.length) {\n      this._emitter.emit('allWorkersRegistered');\n    }\n  }\n\n  cwd(): FilePath {\n    return this._cwd;\n  }\n\n  chdir(dir: FilePath) {\n    this._cwd = dir;\n  }\n\n  _normalizePath(filePath: FilePath, realpath: boolean = true): FilePath {\n    filePath = path.resolve(this.cwd(), filePath);\n\n    // get realpath by following symlinks\n    if (realpath) {\n      let {root, dir, base} = path.parse(filePath);\n      let parts = dir.slice(root.length).split(path.sep).concat(base);\n      let res = root;\n      for (let part of parts) {\n        res = path.join(res, part);\n        let symlink = this.symlinks.get(res);\n        if (symlink) {\n          res = symlink;\n        }\n      }\n\n      return res;\n    }\n\n    return filePath;\n  }\n\n  async writeFile(\n    filePath: FilePath,\n    contents: Buffer | string,\n    options?: ?FileOptions,\n  ) {\n    filePath = this._normalizePath(filePath);\n    if (this.dirs.has(filePath)) {\n      throw new FSError('EISDIR', filePath, 'is a directory');\n    }\n\n    let dir = path.dirname(filePath);\n    if (!this.dirs.has(dir)) {\n      throw new FSError('ENOENT', dir, 'does not exist');\n    }\n\n    let buffer = makeShared(contents);\n    let file = this.files.get(filePath);\n    let mode = (options && options.mode) || 0o666;\n    if (file) {\n      file.write(buffer, mode);\n      this.files.set(filePath, file);\n    } else {\n      this.files.set(filePath, new File(buffer, mode));\n    }\n\n    await this._sendWorkerEvent({\n      type: 'writeFile',\n      path: filePath,\n      entry: this.files.get(filePath),\n    });\n\n    this._triggerEvent({\n      type: file ? 'update' : 'create',\n      path: filePath,\n    });\n  }\n\n  // eslint-disable-next-line require-await\n  async readFile(filePath: FilePath, encoding?: Encoding): Promise<any> {\n    return this.readFileSync(filePath, encoding);\n  }\n\n  readFileSync(filePath: FilePath, encoding?: Encoding): any {\n    filePath = this._normalizePath(filePath);\n    let file = this.files.get(filePath);\n    if (file == null) {\n      throw new FSError('ENOENT', filePath, 'does not exist');\n    }\n\n    let buffer = file.read();\n    if (encoding) {\n      return buffer.toString(encoding);\n    }\n\n    return buffer;\n  }\n\n  async copyFile(source: FilePath, destination: FilePath) {\n    let contents = await this.readFile(source);\n    await this.writeFile(destination, contents);\n  }\n\n  statSync(filePath: FilePath): Stat {\n    filePath = this._normalizePath(filePath);\n\n    let dir = this.dirs.get(filePath);\n    if (dir) {\n      return dir.stat();\n    }\n\n    let file = this.files.get(filePath);\n    if (file == null) {\n      throw new FSError('ENOENT', filePath, 'does not exist');\n    }\n\n    return file.stat();\n  }\n\n  // eslint-disable-next-line require-await\n  async stat(filePath: FilePath): Promise<Stat> {\n    return this.statSync(filePath);\n  }\n\n  readdirSync(dir: FilePath, opts?: ReaddirOptions): any {\n    dir = this._normalizePath(dir);\n    if (!this.dirs.has(dir)) {\n      throw new FSError('ENOENT', dir, 'does not exist');\n    }\n\n    dir += path.sep;\n\n    let res = [];\n    for (let [filePath, entry] of this.dirs) {\n      if (\n        filePath.startsWith(dir) &&\n        filePath.indexOf(path.sep, dir.length) === -1\n      ) {\n        let name = filePath.slice(dir.length);\n        if (opts?.withFileTypes) {\n          res.push(new Dirent(name, entry));\n        } else {\n          res.push(name);\n        }\n      }\n    }\n\n    for (let [filePath, entry] of this.files) {\n      if (\n        filePath.startsWith(dir) &&\n        filePath.indexOf(path.sep, dir.length) === -1\n      ) {\n        let name = filePath.slice(dir.length);\n        if (opts?.withFileTypes) {\n          res.push(new Dirent(name, entry));\n        } else {\n          res.push(name);\n        }\n      }\n    }\n\n    for (let [from] of this.symlinks) {\n      if (from.startsWith(dir) && from.indexOf(path.sep, dir.length) === -1) {\n        let name = from.slice(dir.length);\n        if (opts?.withFileTypes) {\n          res.push(new Dirent(name, {mode: S_IFLNK}));\n        } else {\n          res.push(name);\n        }\n      }\n    }\n\n    return res;\n  }\n\n  // eslint-disable-next-line require-await\n  async readdir(dir: FilePath, opts?: ReaddirOptions): Promise<any> {\n    return this.readdirSync(dir, opts);\n  }\n\n  async unlink(filePath: FilePath): Promise<void> {\n    filePath = this._normalizePath(filePath);\n    if (!this.files.has(filePath) && !this.dirs.has(filePath)) {\n      throw new FSError('ENOENT', filePath, 'does not exist');\n    }\n\n    this.files.delete(filePath);\n    this.dirs.delete(filePath);\n    this.watchers.delete(filePath);\n\n    await this._sendWorkerEvent({\n      type: 'unlink',\n      path: filePath,\n    });\n\n    this._triggerEvent({\n      type: 'delete',\n      path: filePath,\n    });\n\n    return Promise.resolve();\n  }\n\n  async mkdirp(dir: FilePath): Promise<void> {\n    dir = this._normalizePath(dir);\n    if (this.dirs.has(dir)) {\n      return Promise.resolve();\n    }\n\n    if (this.files.has(dir)) {\n      throw new FSError('ENOENT', dir, 'is not a directory');\n    }\n\n    let root = path.parse(dir).root;\n    while (dir !== root) {\n      if (this.dirs.has(dir)) {\n        break;\n      }\n\n      this.dirs.set(dir, new Directory());\n      await this._sendWorkerEvent({\n        type: 'mkdir',\n        path: dir,\n      });\n\n      this._triggerEvent({\n        type: 'create',\n        path: dir,\n      });\n\n      dir = path.dirname(dir);\n    }\n\n    return Promise.resolve();\n  }\n\n  async rimraf(filePath: FilePath): Promise<void> {\n    filePath = this._normalizePath(filePath);\n\n    if (this.dirs.has(filePath)) {\n      let dir = filePath + path.sep;\n      for (let filePath of this.files.keys()) {\n        if (filePath.startsWith(dir)) {\n          this.files.delete(filePath);\n          await this._sendWorkerEvent({\n            type: 'unlink',\n            path: filePath,\n          });\n\n          this._triggerEvent({\n            type: 'delete',\n            path: filePath,\n          });\n        }\n      }\n\n      for (let dirPath of this.dirs.keys()) {\n        if (dirPath.startsWith(dir)) {\n          this.dirs.delete(dirPath);\n          this.watchers.delete(dirPath);\n          await this._sendWorkerEvent({\n            type: 'unlink',\n            path: filePath,\n          });\n\n          this._triggerEvent({\n            type: 'delete',\n            path: dirPath,\n          });\n        }\n      }\n\n      for (let filePath of this.symlinks.keys()) {\n        if (filePath.startsWith(dir)) {\n          this.symlinks.delete(filePath);\n          await this._sendWorkerEvent({\n            type: 'unlink',\n            path: filePath,\n          });\n        }\n      }\n\n      this.dirs.delete(filePath);\n      await this._sendWorkerEvent({\n        type: 'unlink',\n        path: filePath,\n      });\n\n      this._triggerEvent({\n        type: 'delete',\n        path: filePath,\n      });\n    } else if (this.files.has(filePath)) {\n      this.files.delete(filePath);\n      await this._sendWorkerEvent({\n        type: 'unlink',\n        path: filePath,\n      });\n\n      this._triggerEvent({\n        type: 'delete',\n        path: filePath,\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  async ncp(source: FilePath, destination: FilePath) {\n    source = this._normalizePath(source);\n\n    if (this.dirs.has(source)) {\n      if (!this.dirs.has(destination)) {\n        this.dirs.set(destination, new Directory());\n        await this._sendWorkerEvent({\n          type: 'mkdir',\n          path: destination,\n        });\n\n        this._triggerEvent({\n          type: 'create',\n          path: destination,\n        });\n      }\n\n      let dir = source + path.sep;\n      for (let dirPath of this.dirs.keys()) {\n        if (dirPath.startsWith(dir)) {\n          let destName = path.join(destination, dirPath.slice(dir.length));\n          if (!this.dirs.has(destName)) {\n            this.dirs.set(destName, new Directory());\n            await this._sendWorkerEvent({\n              type: 'mkdir',\n              path: destination,\n            });\n            this._triggerEvent({\n              type: 'create',\n              path: destName,\n            });\n          }\n        }\n      }\n\n      for (let [filePath, file] of this.files) {\n        if (filePath.startsWith(dir)) {\n          let destName = path.join(destination, filePath.slice(dir.length));\n          let exists = this.files.has(destName);\n          this.files.set(destName, file);\n          await this._sendWorkerEvent({\n            type: 'writeFile',\n            path: destName,\n            entry: file,\n          });\n\n          this._triggerEvent({\n            type: exists ? 'update' : 'create',\n            path: destName,\n          });\n        }\n      }\n    } else {\n      await this.copyFile(source, destination);\n    }\n  }\n\n  createReadStream(filePath: FilePath): ReadStream {\n    return new ReadStream(this, filePath);\n  }\n\n  createWriteStream(filePath: FilePath, options: ?FileOptions): WriteStream {\n    return new WriteStream(this, filePath, options);\n  }\n\n  realpathSync(filePath: FilePath): FilePath {\n    return this._normalizePath(filePath);\n  }\n\n  // eslint-disable-next-line require-await\n  async realpath(filePath: FilePath): Promise<FilePath> {\n    return this.realpathSync(filePath);\n  }\n\n  async symlink(target: FilePath, path: FilePath) {\n    target = this._normalizePath(target);\n    path = this._normalizePath(path);\n    this.symlinks.set(path, target);\n    await this._sendWorkerEvent({\n      type: 'symlink',\n      path,\n      target,\n    });\n  }\n\n  existsSync(filePath: FilePath): boolean {\n    filePath = this._normalizePath(filePath);\n    return this.files.has(filePath) || this.dirs.has(filePath);\n  }\n\n  // eslint-disable-next-line require-await\n  async exists(filePath: FilePath): Promise<boolean> {\n    return this.existsSync(filePath);\n  }\n\n  _triggerEvent(event: Event) {\n    this.events.push(event);\n    if (this.watchers.size === 0) {\n      return;\n    }\n\n    // Batch events\n    this._eventQueue.push(event);\n    clearTimeout(this._watcherTimer);\n\n    this._watcherTimer = setTimeout(() => {\n      let events = this._eventQueue;\n      this._eventQueue = [];\n\n      for (let [dir, watchers] of this.watchers) {\n        if (!dir.endsWith(path.sep)) {\n          dir += path.sep;\n        }\n\n        if (event.path.startsWith(dir)) {\n          for (let watcher of watchers) {\n            watcher.trigger(events);\n          }\n        }\n      }\n    }, 50);\n  }\n\n  _registerWorker(handle: Handle) {\n    this._workerHandles.push(handle);\n    if (this._numWorkerInstances === this._workerHandles.length) {\n      this._emitter.emit('allWorkersRegistered');\n    }\n  }\n\n  async _sendWorkerEvent(event: WorkerEvent) {\n    // Wait for worker instances to register their handles\n    while (this._workerHandles.length < this._numWorkerInstances) {\n      await new Promise(resolve => this._workerRegisterResolves.push(resolve));\n    }\n\n    await Promise.all(\n      this._workerHandles.map(workerHandle =>\n        this.farm.workerApi.runHandle(workerHandle, [event]),\n      ),\n    );\n  }\n\n  watch(\n    dir: FilePath,\n    fn: (err: ?Error, events: Array<Event>) => mixed,\n    opts: WatcherOptions,\n  ): Promise<AsyncSubscription> {\n    dir = this._normalizePath(dir);\n    let watcher = new Watcher(fn, opts);\n    let watchers = this.watchers.get(dir);\n    if (!watchers) {\n      watchers = new Set();\n      this.watchers.set(dir, watchers);\n    }\n\n    watchers.add(watcher);\n\n    return Promise.resolve({\n      unsubscribe: () => {\n        watchers = nullthrows(watchers);\n        watchers.delete(watcher);\n\n        if (watchers.size === 0) {\n          this.watchers.delete(dir);\n        }\n\n        return Promise.resolve();\n      },\n    });\n  }\n\n  async getEventsSince(\n    dir: FilePath,\n    snapshot: FilePath,\n    opts: WatcherOptions,\n  ): Promise<Array<Event>> {\n    let contents = await this.readFile(snapshot, 'utf8');\n    let len = Number(contents);\n    let events = this.events.slice(len);\n    let ignore = opts.ignore;\n    if (ignore) {\n      events = events.filter(\n        event => !ignore.some(i => event.path.startsWith(i + path.sep)),\n      );\n    }\n\n    return events;\n  }\n\n  async writeSnapshot(dir: FilePath, snapshot: FilePath): Promise<void> {\n    await this.writeFile(snapshot, '' + this.events.length);\n  }\n\n  findAncestorFile(\n    fileNames: Array<string>,\n    fromDir: FilePath,\n    root: FilePath,\n  ): ?FilePath {\n    return findAncestorFile(this, fileNames, fromDir, root);\n  }\n\n  findNodeModule(moduleName: string, fromDir: FilePath): ?FilePath {\n    return findNodeModule(this, moduleName, fromDir);\n  }\n\n  findFirstFile(filePaths: Array<FilePath>): ?FilePath {\n    return findFirstFile(this, filePaths);\n  }\n}\n\nclass Watcher {\n  fn: (err: ?Error, events: Array<Event>) => mixed;\n  options: WatcherOptions;\n\n  constructor(\n    fn: (err: ?Error, events: Array<Event>) => mixed,\n    options: WatcherOptions,\n  ) {\n    this.fn = fn;\n    this.options = options;\n  }\n\n  trigger(events: Array<Event>) {\n    let ignore = this.options.ignore;\n    if (ignore) {\n      events = events.filter(\n        event => !ignore.some(i => event.path.startsWith(i + path.sep)),\n      );\n    }\n\n    if (events.length > 0) {\n      this.fn(null, events);\n    }\n  }\n}\n\nclass FSError extends Error {\n  code: string;\n  path: FilePath;\n  constructor(code: string, path: FilePath, message: string) {\n    super(`${code}: ${path} ${message}`);\n    this.name = 'FSError';\n    this.code = code;\n    this.path = path;\n    Error.captureStackTrace?.(this, this.constructor);\n  }\n}\n\nclass ReadStream extends Readable {\n  fs: FileSystem;\n  filePath: FilePath;\n  reading: boolean;\n  bytesRead: number;\n  constructor(fs: FileSystem, filePath: FilePath) {\n    super();\n    this.fs = fs;\n    this.filePath = filePath;\n    this.reading = false;\n    this.bytesRead = 0;\n  }\n\n  _read() {\n    if (this.reading) {\n      return;\n    }\n\n    this.reading = true;\n    this.fs.readFile(this.filePath).then(\n      res => {\n        this.bytesRead += res.byteLength;\n        this.push(res);\n        this.push(null);\n      },\n      err => {\n        this.emit('error', err);\n      },\n    );\n  }\n}\n\nclass WriteStream extends Writable {\n  fs: FileSystem;\n  filePath: FilePath;\n  options: ?FileOptions;\n  buffer: Buffer;\n\n  constructor(fs: FileSystem, filePath: FilePath, options: ?FileOptions) {\n    super({emitClose: true, autoDestroy: true});\n    this.fs = fs;\n    this.filePath = filePath;\n    this.options = options;\n    this.buffer = Buffer.alloc(0);\n  }\n\n  _write(\n    chunk: Buffer | string,\n    encoding: any,\n    callback: (error?: Error) => void,\n  ) {\n    let c = typeof chunk === 'string' ? Buffer.from(chunk, encoding) : chunk;\n    this.buffer = Buffer.concat([this.buffer, c]);\n    callback();\n  }\n\n  _final(callback: (error?: Error) => void) {\n    this.fs\n      .writeFile(this.filePath, this.buffer, this.options)\n      .then(callback)\n      .catch(callback);\n  }\n}\n\nconst S_IFREG = 0o100000;\nconst S_IFDIR = 0o040000;\nconst S_IFLNK = 0o120000;\n\nclass Entry {\n  mode: number;\n  atime: number;\n  mtime: number;\n  ctime: number;\n  birthtime: number;\n  constructor(mode: number) {\n    this.mode = mode;\n    let now = Date.now();\n    this.atime = now;\n    this.mtime = now;\n    this.ctime = now;\n    this.birthtime = now;\n  }\n\n  access() {\n    let now = Date.now();\n    this.atime = now;\n    this.ctime = now;\n  }\n\n  modify(mode: number) {\n    let now = Date.now();\n    this.mtime = now;\n    this.ctime = now;\n    this.mode = mode;\n  }\n\n  getSize(): number {\n    return 0;\n  }\n\n  stat(): Stat {\n    return new Stat(this);\n  }\n}\n\nclass Stat {\n  dev: number = 0;\n  ino: number = 0;\n  mode: number;\n  nlink: number = 0;\n  uid: number = 0;\n  gid: number = 0;\n  rdev: number = 0;\n  size: number;\n  blksize: number = 0;\n  blocks: number = 0;\n  atimeMs: number;\n  mtimeMs: number;\n  ctimeMs: number;\n  birthtimeMs: number;\n  atime: Date;\n  mtime: Date;\n  ctime: Date;\n  birthtime: Date;\n\n  constructor(entry: Entry) {\n    this.mode = entry.mode;\n    this.size = entry.getSize();\n    this.atimeMs = entry.atime;\n    this.mtimeMs = entry.mtime;\n    this.ctimeMs = entry.ctime;\n    this.birthtimeMs = entry.birthtime;\n    this.atime = new Date(entry.atime);\n    this.mtime = new Date(entry.mtime);\n    this.ctime = new Date(entry.ctime);\n    this.birthtime = new Date(entry.birthtime);\n  }\n\n  isFile(): boolean {\n    return Boolean(this.mode & S_IFREG);\n  }\n\n  isDirectory(): boolean {\n    return Boolean(this.mode & S_IFDIR);\n  }\n\n  isBlockDevice(): boolean {\n    return false;\n  }\n\n  isCharacterDevice(): boolean {\n    return false;\n  }\n\n  isSymbolicLink(): boolean {\n    return false;\n  }\n\n  isFIFO(): boolean {\n    return false;\n  }\n\n  isSocket(): boolean {\n    return false;\n  }\n}\n\nclass Dirent {\n  name: string;\n  #mode: number;\n\n  constructor(name: string, entry: interface {mode: number}) {\n    this.name = name;\n    this.#mode = entry.mode;\n  }\n\n  isFile(): boolean {\n    return Boolean(this.#mode & S_IFREG);\n  }\n\n  isDirectory(): boolean {\n    return Boolean(this.#mode & S_IFDIR);\n  }\n\n  isBlockDevice(): boolean {\n    return false;\n  }\n\n  isCharacterDevice(): boolean {\n    return false;\n  }\n\n  isSymbolicLink(): boolean {\n    return Boolean(this.#mode & S_IFLNK);\n  }\n\n  isFIFO(): boolean {\n    return false;\n  }\n\n  isSocket(): boolean {\n    return false;\n  }\n}\n\nclass File extends Entry {\n  buffer: Buffer;\n  constructor(buffer: Buffer, mode: number) {\n    super(S_IFREG | mode);\n    this.buffer = buffer;\n  }\n\n  read(): Buffer {\n    super.access();\n    return Buffer.from(this.buffer);\n  }\n\n  write(buffer: Buffer, mode: number) {\n    super.modify(S_IFREG | mode);\n    this.buffer = buffer;\n  }\n\n  getSize(): number {\n    return this.buffer.byteLength;\n  }\n}\n\nclass Directory extends Entry {\n  constructor() {\n    super(S_IFDIR);\n  }\n}\n\nfunction makeShared(contents: Buffer | string): Buffer {\n  if (typeof contents !== 'string' && contents.buffer instanceof SharedBuffer) {\n    return contents;\n  }\n\n  let length = Buffer.byteLength(contents);\n  let shared = new SharedBuffer(length);\n  let buffer = Buffer.from(shared);\n  if (typeof contents === 'string') {\n    buffer.write(contents);\n  } else {\n    buffer.set(contents);\n  }\n\n  return buffer;\n}\n\nclass WorkerFS extends MemoryFS {\n  id: number;\n  handleFn: HandleFunction;\n\n  constructor(id: number, handle: Handle) {\n    // TODO Make this not a subclass\n    // $FlowFixMe\n    super();\n    this.id = id;\n    this.handleFn = (methodName, args) =>\n      WorkerFarm.getWorkerApi().runHandle(handle, [methodName, args]);\n\n    this.handleFn('_registerWorker', [\n      WorkerFarm.getWorkerApi().createReverseHandle(event => {\n        switch (event.type) {\n          case 'writeFile':\n            this.files.set(event.path, event.entry);\n            break;\n          case 'unlink':\n            this.files.delete(event.path);\n            this.dirs.delete(event.path);\n            this.symlinks.delete(event.path);\n            break;\n          case 'mkdir':\n            this.dirs.set(event.path, new Directory());\n            break;\n          case 'symlink':\n            this.symlinks.set(event.path, event.target);\n            break;\n        }\n      }),\n    ]);\n  }\n\n  static deserialize(opts: SerializedMemoryFS): MemoryFS {\n    return nullthrows(instances.get(opts.id));\n  }\n\n  serialize(): SerializedMemoryFS {\n    // $FlowFixMe\n    return {\n      id: this.id,\n    };\n  }\n\n  writeFile(\n    filePath: FilePath,\n    contents: Buffer | string,\n    options: ?FileOptions,\n  ): Promise<void> {\n    super.writeFile(filePath, contents, options);\n    let buffer = makeShared(contents);\n    return this.handleFn('writeFile', [filePath, buffer, options]);\n  }\n\n  unlink(filePath: FilePath): Promise<void> {\n    super.unlink(filePath);\n    return this.handleFn('unlink', [filePath]);\n  }\n\n  mkdirp(dir: FilePath): Promise<void> {\n    super.mkdirp(dir);\n    return this.handleFn('mkdirp', [dir]);\n  }\n\n  rimraf(filePath: FilePath): Promise<void> {\n    super.rimraf(filePath);\n    return this.handleFn('rimraf', [filePath]);\n  }\n\n  ncp(source: FilePath, destination: FilePath): Promise<void> {\n    super.ncp(source, destination);\n    return this.handleFn('ncp', [source, destination]);\n  }\n\n  symlink(target: FilePath, path: FilePath): Promise<void> {\n    super.symlink(target, path);\n    return this.handleFn('symlink', [target, path]);\n  }\n}\n\nregisterSerializableClass(`${packageJSON.version}:MemoryFS`, MemoryFS);\nregisterSerializableClass(`${packageJSON.version}:WorkerFS`, WorkerFS);\nregisterSerializableClass(`${packageJSON.version}:Stat`, Stat);\nregisterSerializableClass(`${packageJSON.version}:File`, File);\nregisterSerializableClass(`${packageJSON.version}:Directory`, Directory);\n","{\n  \"name\": \"@parcel/fs\",\n  \"version\": \"2.9.3\",\n  \"description\": \"Blazing fast, zero configuration web application bundler\",\n  \"license\": \"MIT\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"funding\": {\n    \"type\": \"opencollective\",\n    \"url\": \"https://opencollective.com/parcel\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/parcel-bundler/parcel.git\"\n  },\n  \"main\": \"lib/index.js\",\n  \"source\": \"src/index.js\",\n  \"types\": \"index.d.ts\",\n  \"engines\": {\n    \"node\": \">= 12.0.0\"\n  },\n  \"targets\": {\n    \"types\": false,\n    \"main\": {\n      \"includeNodeModules\": {\n        \"@parcel/core\": false,\n        \"@parcel/fs-search\": false,\n        \"@parcel/types\": false,\n        \"@parcel/utils\": false,\n        \"@parcel/watcher\": false,\n        \"@parcel/workers\": false\n      }\n    },\n    \"browser\": {\n      \"includeNodeModules\": {\n        \"@parcel/core\": false,\n        \"@parcel/fs-search\": false,\n        \"@parcel/types\": false,\n        \"@parcel/utils\": false,\n        \"@parcel/watcher\": false,\n        \"@parcel/workers\": false\n      }\n    }\n  },\n  \"scripts\": {\n    \"build-ts\": \"mkdir -p lib && flow-to-ts src/types.js > lib/types.d.ts\",\n    \"check-ts\": \"tsc --noEmit index.d.ts\"\n  },\n  \"dependencies\": {\n    \"@parcel/fs-search\": \"2.9.3\",\n    \"@parcel/types\": \"2.9.3\",\n    \"@parcel/utils\": \"2.9.3\",\n    \"@parcel/watcher\": \"^2.0.7\",\n    \"@parcel/workers\": \"2.9.3\"\n  },\n  \"devDependencies\": {\n    \"graceful-fs\": \"^4.2.4\",\n    \"ncp\": \"^2.0.0\",\n    \"nullthrows\": \"^1.1.1\",\n    \"utility-types\": \"^3.10.0\"\n  },\n  \"peerDependencies\": {\n    \"@parcel/core\": \"^2.9.3\"\n  },\n  \"browser\": {\n    \"@parcel/fs\": \"./lib/browser.js\",\n    \"./src/NodeFS.js\": \"./src/NodeFS.browser.js\"\n  },\n  \"gitHead\": \"db3bcae10497fa6a712fd9a135f93f26c5745454\"\n}\n","'use strict';\n\nfunction nullthrows(x, message) {\n  if (x != null) {\n    return x;\n  }\n  var error = new Error(message !== undefined ? message : 'Got unexpected ' + x);\n  error.framesToPop = 1; // Skip nullthrows's own stack frame.\n  throw error;\n}\n\nmodule.exports = nullthrows;\nmodule.exports.default = nullthrows;\n\nObject.defineProperty(module.exports, '__esModule', {value: true});\n","// @flow\nimport type {FilePath} from '@parcel/types';\nimport type {FileSystem} from './types';\nimport path from 'path';\n\nexport function findNodeModule(\n  fs: FileSystem,\n  moduleName: string,\n  dir: FilePath,\n): ?FilePath {\n  let {root} = path.parse(dir);\n  while (dir !== root) {\n    // Skip node_modules directories\n    if (path.basename(dir) === 'node_modules') {\n      dir = path.dirname(dir);\n    }\n\n    try {\n      let moduleDir = path.join(dir, 'node_modules', moduleName);\n      let stats = fs.statSync(moduleDir);\n      if (stats.isDirectory()) {\n        return moduleDir;\n      }\n    } catch (err) {\n      // ignore\n    }\n\n    // Move up a directory\n    dir = path.dirname(dir);\n  }\n\n  return null;\n}\n\nexport function findAncestorFile(\n  fs: FileSystem,\n  fileNames: Array<string>,\n  dir: FilePath,\n  root: FilePath,\n): ?FilePath {\n  let {root: pathRoot} = path.parse(dir);\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (path.basename(dir) === 'node_modules') {\n      return null;\n    }\n\n    for (const fileName of fileNames) {\n      let filePath = path.join(dir, fileName);\n      try {\n        if (fs.statSync(filePath).isFile()) {\n          return filePath;\n        }\n      } catch (err) {\n        // ignore\n      }\n    }\n\n    if (dir === root || dir === pathRoot) {\n      break;\n    }\n\n    dir = path.dirname(dir);\n  }\n\n  return null;\n}\n\nexport function findFirstFile(\n  fs: FileSystem,\n  filePaths: Array<FilePath>,\n): ?FilePath {\n  for (let filePath of filePaths) {\n    try {\n      if (fs.statSync(filePath).isFile()) {\n        return filePath;\n      }\n    } catch (err) {\n      // ignore\n    }\n  }\n}\n","// @flow\n\nimport type {Stats} from 'fs';\nimport type {FileSystem, ReaddirOptions} from './types';\nimport type {FilePath} from '@parcel/types';\nimport type {\n  Event,\n  Options as WatcherOptions,\n  AsyncSubscription,\n} from '@parcel/watcher';\n\nimport {registerSerializableClass} from '@parcel/core';\nimport packageJSON from '../package.json';\nimport {findAncestorFile, findNodeModule, findFirstFile} from './find';\n\nfunction read(method) {\n  return async function (...args: Array<any>) {\n    try {\n      return await this.writable[method](...args);\n    } catch (err) {\n      return this.readable[method](...args);\n    }\n  };\n}\n\nfunction readSync(method) {\n  return function (...args: Array<any>) {\n    try {\n      return this.writable[method](...args);\n    } catch (err) {\n      return this.readable[method](...args);\n    }\n  };\n}\n\nfunction write(method) {\n  return function (...args: Array<any>) {\n    return this.writable[method](...args);\n  };\n}\n\nfunction checkExists(method) {\n  return function (filePath: FilePath, ...args: Array<any>) {\n    if (this.writable.existsSync(filePath)) {\n      return this.writable[method](filePath, ...args);\n    }\n\n    return this.readable[method](filePath, ...args);\n  };\n}\n\nexport class OverlayFS implements FileSystem {\n  writable: FileSystem;\n  readable: FileSystem;\n  constructor(writable: FileSystem, readable: FileSystem) {\n    this.writable = writable;\n    this.readable = readable;\n  }\n\n  static deserialize(opts: any): OverlayFS {\n    return new OverlayFS(opts.writable, opts.readable);\n  }\n\n  serialize(): {|$$raw: boolean, readable: FileSystem, writable: FileSystem|} {\n    return {\n      $$raw: false,\n      writable: this.writable,\n      readable: this.readable,\n    };\n  }\n\n  readFile: (...args: Array<any>) => Promise<Buffer & string & $Shape<Stats>> =\n    read('readFile');\n  writeFile: (...args: Array<any>) => any = write('writeFile');\n  async copyFile(source: FilePath, destination: FilePath) {\n    if (await this.writable.exists(source)) {\n      await this.writable.writeFile(\n        destination,\n        await this.writable.readFile(source),\n      );\n    } else {\n      await this.writable.writeFile(\n        destination,\n        await this.readable.readFile(source),\n      );\n    }\n  }\n  stat: (...args: Array<any>) => Promise<Buffer & string & $Shape<Stats>> =\n    read('stat');\n  unlink: (...args: Array<any>) => any = write('unlink');\n  mkdirp: (...args: Array<any>) => any = write('mkdirp');\n  rimraf: (...args: Array<any>) => any = write('rimraf');\n  ncp: (...args: Array<any>) => any = write('ncp');\n  createReadStream: (filePath: FilePath, ...args: Array<any>) => any =\n    checkExists('createReadStream');\n  createWriteStream: (...args: Array<any>) => any = write('createWriteStream');\n  cwd: (...args: Array<any>) => any = readSync('cwd');\n  chdir: (...args: Array<any>) => any = readSync('chdir');\n  realpath: (filePath: FilePath, ...args: Array<any>) => any =\n    checkExists('realpath');\n\n  readFileSync: (...args: Array<any>) => any = readSync('readFileSync');\n  statSync: (...args: Array<any>) => any = readSync('statSync');\n  existsSync: (...args: Array<any>) => any = readSync('existsSync');\n  realpathSync: (filePath: FilePath, ...args: Array<any>) => any =\n    checkExists('realpathSync');\n\n  async exists(filePath: FilePath): Promise<boolean> {\n    return (\n      (await this.writable.exists(filePath)) || this.readable.exists(filePath)\n    );\n  }\n\n  async readdir(path: FilePath, opts?: ReaddirOptions): Promise<any> {\n    // Read from both filesystems and merge the results\n    let writable = [];\n    let readable = [];\n    try {\n      writable = await this.writable.readdir(path, opts);\n    } catch (err) {\n      // do nothing\n    }\n\n    try {\n      readable = await this.readable.readdir(path, opts);\n    } catch (err) {\n      // do nothing\n    }\n\n    return Array.from(new Set([...writable, ...readable]));\n  }\n\n  readdirSync(path: FilePath, opts?: ReaddirOptions): any {\n    // Read from both filesystems and merge the results\n    let writable = [];\n    let readable = [];\n    try {\n      writable = this.writable.readdirSync(path, opts);\n    } catch (err) {\n      // do nothing\n    }\n\n    try {\n      readable = this.readable.readdirSync(path, opts);\n    } catch (err) {\n      // do nothing\n    }\n\n    return Array.from(new Set([...writable, ...readable]));\n  }\n\n  async watch(\n    dir: FilePath,\n    fn: (err: ?Error, events: Array<Event>) => mixed,\n    opts: WatcherOptions,\n  ): Promise<AsyncSubscription> {\n    let writableSubscription = await this.writable.watch(dir, fn, opts);\n    let readableSubscription = await this.readable.watch(dir, fn, opts);\n    return {\n      unsubscribe: async () => {\n        await writableSubscription.unsubscribe();\n        await readableSubscription.unsubscribe();\n      },\n    };\n  }\n\n  async getEventsSince(\n    dir: FilePath,\n    snapshot: FilePath,\n    opts: WatcherOptions,\n  ): Promise<Array<Event>> {\n    let writableEvents = await this.writable.getEventsSince(\n      dir,\n      snapshot,\n      opts,\n    );\n    let readableEvents = await this.readable.getEventsSince(\n      dir,\n      snapshot,\n      opts,\n    );\n    return [...writableEvents, ...readableEvents];\n  }\n\n  async writeSnapshot(\n    dir: FilePath,\n    snapshot: FilePath,\n    opts: WatcherOptions,\n  ): Promise<void> {\n    await this.writable.writeSnapshot(dir, snapshot, opts);\n  }\n\n  findAncestorFile(\n    fileNames: Array<string>,\n    fromDir: FilePath,\n    root: FilePath,\n  ): ?FilePath {\n    return findAncestorFile(this, fileNames, fromDir, root);\n  }\n\n  findNodeModule(moduleName: string, fromDir: FilePath): ?FilePath {\n    return findNodeModule(this, moduleName, fromDir);\n  }\n\n  findFirstFile(filePaths: Array<FilePath>): ?FilePath {\n    return findFirstFile(this, filePaths);\n  }\n}\n\nregisterSerializableClass(`${packageJSON.version}:OverlayFS`, OverlayFS);\n"],"names":["path","stream","promisify","pipeline","ncp","sourceFS","source","destinationFS","destination","mkdirp","files","readdir","file","sourcePath","join","destPath","stats","stat","isFile","createReadStream","createWriteStream","isDirectory","NodeFS","constructor","Error","Readable","Writable","registerSerializableClass","SharedBuffer","packageJSON","WorkerFarm","Handle","nullthrows","EventEmitter","findAncestorFile","findNodeModule","findFirstFile","instances","Map","id","MemoryFS","_numWorkerInstances","_workerRegisterResolves","_emitter","workerFarm","farm","dirs","Directory","symlinks","watchers","events","_cwd","_workerHandles","_eventQueue","set","on","resolve","deserialize","opts","existing","get","getWorkerApi","runHandle","handle","fs","WorkerFS","serialize","createReverseHandle","fn","args","$$raw","decrementWorkerInstance","length","emit","cwd","chdir","dir","_normalizePath","filePath","realpath","root","base","parse","parts","slice","split","sep","concat","res","part","symlink","writeFile","contents","options","has","FSError","dirname","buffer","makeShared","mode","write","File","_sendWorkerEvent","type","entry","_triggerEvent","readFile","encoding","readFileSync","read","toString","copyFile","statSync","readdirSync","startsWith","indexOf","name","withFileTypes","push","Dirent","from","S_IFLNK","unlink","delete","Promise","rimraf","keys","dirPath","destName","exists","ReadStream","WriteStream","realpathSync","target","existsSync","event","size","clearTimeout","_watcherTimer","setTimeout","endsWith","watcher","trigger","_registerWorker","all","map","workerHandle","workerApi","watch","Watcher","Set","add","unsubscribe","getEventsSince","snapshot","len","Number","ignore","filter","some","i","writeSnapshot","fileNames","fromDir","moduleName","filePaths","code","message","captureStackTrace","reading","bytesRead","_read","then","byteLength","err","emitClose","autoDestroy","Buffer","alloc","_write","chunk","callback","c","_final","catch","S_IFREG","S_IFDIR","Entry","now","Date","atime","mtime","ctime","birthtime","access","modify","getSize","Stat","dev","ino","nlink","uid","gid","rdev","blksize","blocks","atimeMs","mtimeMs","ctimeMs","birthtimeMs","Boolean","isBlockDevice","isCharacterDevice","isSymbolicLink","isFIFO","isSocket","shared","handleFn","methodName","version","module","exports","JSON","basename","moduleDir","pathRoot","fileName","method","writable","readable","readSync","checkExists","OverlayFS","Array","writableSubscription","readableSubscription","writableEvents","readableEvents"],"version":3,"file":"browser.js.map"}